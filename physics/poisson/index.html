<!doctype html><html lang=en><head><title>Solution of Poisson's equation over a polygonal domain · AI for HUMANITY</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Mohamed ABDUL GAFOOR"><meta name=description content="Poisson&rsquo;s Equation
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-
Poisson&rsquo;s equation is a fundamental partial differential equation that arises in many areas of science and engineering. It is used to describe the behavior of scalar fields in physical systems such as electric potential or temperature distribution. The equation is expressed in terms of a source term and describes the distribution of the scalar field in a given physical system. Solving Poisson&rsquo;s equation is a fundamental problem in many areas of research, including mathematical physics, engineering, and applied mathematics."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Solution of Poisson's equation over a polygonal domain"><meta name=twitter:description content="Poisson&rsquo;s Equation
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-
Poisson&rsquo;s equation is a fundamental partial differential equation that arises in many areas of science and engineering. It is used to describe the behavior of scalar fields in physical systems such as electric potential or temperature distribution. The equation is expressed in terms of a source term and describes the distribution of the scalar field in a given physical system. Solving Poisson&rsquo;s equation is a fundamental problem in many areas of research, including mathematical physics, engineering, and applied mathematics."><meta property="og:title" content="Solution of Poisson's equation over a polygonal domain"><meta property="og:description" content="Poisson&rsquo;s Equation
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-
Poisson&rsquo;s equation is a fundamental partial differential equation that arises in many areas of science and engineering. It is used to describe the behavior of scalar fields in physical systems such as electric potential or temperature distribution. The equation is expressed in terms of a source term and describes the distribution of the scalar field in a given physical system. Solving Poisson&rsquo;s equation is a fundamental problem in many areas of research, including mathematical physics, engineering, and applied mathematics."><meta property="og:type" content="article"><meta property="og:url" content="https://AIThoughtLab.github.io/ThinkingAI/physics/poisson/"><meta property="article:section" content="physics"><meta property="article:published_time" content="2023-01-25T00:00:00+00:00"><meta property="article:modified_time" content="2023-01-25T00:00:00+00:00"><link rel=canonical href=https://AIThoughtLab.github.io/ThinkingAI/physics/poisson/><link rel=preload href="https://AIThoughtLab.github.io/ThinkingAI/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=https://AIThoughtLab.github.io/ThinkingAI/css/coder.min.36f76aaf39a14ecf5c3a3c6250dcaf06c238b3d8365d17d646f95cb1874e852b.css integrity="sha256-NvdqrzmhTs9cOjxiUNyvBsI4s9g2XRfWRvlcsYdOhSs=" crossorigin=anonymous media=screen><link rel=stylesheet href=https://AIThoughtLab.github.io/ThinkingAI/css/coder-dark.min.593028e7f7ac55c003b79c230d1cd411bb4ca53b31556c3abb7f027170e646e9.css integrity="sha256-WTAo5/esVcADt5wjDRzUEbtMpTsxVWw6u38CcXDmRuk=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=https://AIThoughtLab.github.io/ThinkingAI/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=https://AIThoughtLab.github.io/ThinkingAI/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=https://AIThoughtLab.github.io/ThinkingAI/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=https://AIThoughtLab.github.io/ThinkingAI/images/apple-touch-icon.png><link rel=manifest href=https://AIThoughtLab.github.io/ThinkingAI/site.webmanifest><link rel=mask-icon href=https://AIThoughtLab.github.io/ThinkingAI/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.111.3"></head><body class="preload-transitions colorscheme-dark"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://AIThoughtLab.github.io/ThinkingAI/>AI for HUMANITY</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=https://AIThoughtLab.github.io/ThinkingAI/about/>About</a></li><li class=navigation-item><a class=navigation-link href=https://AIThoughtLab.github.io/ThinkingAI/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=https://AIThoughtLab.github.io/ThinkingAI/projects/>Projects</a></li><li class=navigation-item><a class=navigation-link href=https://AIThoughtLab.github.io/ThinkingAI/physics/>PINN</a></li><li class=navigation-item><a class=navigation-link href=https://AIThoughtLab.github.io/ThinkingAI/innovations/>Innovations</a></li><li class=navigation-item><a class=navigation-link href=https://AIThoughtLab.github.io/ThinkingAI/personal/>Personal</a></li><li class=navigation-item><a class=navigation-link href=https://AIThoughtLab.github.io/ThinkingAI/contact/>Contact me</a></li></ul></section></nav><div class=content><section class="container page"><article><header><h1 class=title><a class=title-link href=https://AIThoughtLab.github.io/ThinkingAI/physics/poisson/>Solution of Poisson's equation over a polygonal domain</a></h1></header><p><strong>Poisson&rsquo;s Equation</strong></p><p><em>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</em><figure class=center><img src=https://AIThoughtLab.github.io/ThinkingAI/images/Poisson.png></figure><em>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</em></p><p>Poisson&rsquo;s equation is a fundamental partial differential equation that arises in many areas of science and engineering. It is used to describe the behavior of scalar fields in physical systems such as electric potential or temperature distribution. The equation is expressed in terms of a source term and describes the distribution of the scalar field in a given physical system. Solving Poisson&rsquo;s equation is a fundamental problem in many areas of research, including mathematical physics, engineering, and applied mathematics. The solution of Poisson&rsquo;s equation can provide insight into the behavior of complex physical systems, such as electromagnetic fields, heat transfer, and fluid dynamics.</p><p>In this post, we will delve into the topic of Poisson&rsquo;s equation over a polygonal domain and explore how to solve them using a deep learning technique. Specially, we will employ a Python library called &ldquo;DeepXDE&rdquo; to accomplish this task. Our polygonal domain has the following shape;</p><p>We will solve the following equation over a rectangle domain \(\Omega = [0, 3] \times [0, 2]\);</p><p>$$\nabla^2u = \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} = -2y $$</p><p>with the Dirichlet boundary conditions of \( u(0,0) = 0, u(3, 0) = 0, u(3, 2) = 18, u(0, 2) = 0\). The exact solution to the above equation is \(u(x, y) = x^2y\)</p><figure class=center><img src=https://AIThoughtLab.github.io/ThinkingAI/images/cg1.png></figure><p>Our computational domain coordinates are \([0, 0], [3, 0], [3, 2], [0, 2].\)</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=font-weight:700>import</span> <span style=font-weight:700>deepxde</span> <span style=font-weight:700>as</span> <span style=font-weight:700>dde</span>
</span></span><span style=display:flex><span><span style=font-weight:700>import</span> <span style=font-weight:700>numpy</span> <span style=font-weight:700>as</span> <span style=font-weight:700>np</span>
</span></span><span style=display:flex><span><span style=font-weight:700>import</span> <span style=font-weight:700>tensorflow</span> <span style=font-weight:700>as</span> <span style=font-weight:700>tf</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>geom = dde.geometry.Rectangle([0,0], [3,2])
</span></span></code></pre></div><p><strong>deepxde.geometry.geometry_2d.Rectangle(xmin, xmax)</strong> takes two argments, xmin – coordinate of bottom left corner & xmax – coordinate of top right corner.</p><p>Next, we define the residual of the Poisson equation;</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=font-weight:700>def</span> pde(x, y):
</span></span><span style=display:flex><span>    dy_xx = dde.grad.hessian(y, x, i=0, j=0)
</span></span><span style=display:flex><span>    dy_yy = dde.grad.hessian(y, x, i=1, j=1)
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> -dy_xx - dy_yy - 2*y
</span></span></code></pre></div><p>In this code, i and j are arguments to the <strong>dde.grad.hessian</strong> function, which computes the Hessian matrix of y with respect to x and y. The Hessian matrix is a matrix of second-order partial derivatives of a scalar-valued function. In two dimensions, the Hessian matrix has the following form:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>[ d²u/dx²  d²u/dxdy ]
</span></span><span style=display:flex><span>[ d²u/dydx   d²u/dy²]
</span></span></code></pre></div><p>Let us define our boundary conditions;</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=font-weight:700>def</span> boundary(x, on_boundary):
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> on_boundary
</span></span></code></pre></div><p>In the above method, the <strong>on_boundary</strong> argument is a Boolean variable that indicates whether a given point in the computational domain is located on the boundary or not. The function returns the value of on_boundary, which is True if the point is on the boundary and False otherwise.</p><p>Dirichlet boundary conditions are defined here as;</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>bc = [
</span></span><span style=display:flex><span>    dde.DirichletBC(geom, lambda x: 0, boundary),
</span></span><span style=display:flex><span>    dde.DirichletBC(geom, lambda x: 0, boundary),
</span></span><span style=display:flex><span>    dde.DirichletBC(geom, lambda x: 18.0 if (np.isclose(x[0].any(), 3.0) and np.isclose(x[1].any(), 2.0)) else 0.0, boundary),
</span></span><span style=display:flex><span>    dde.DirichletBC(geom, lambda x: 0, boundary)
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>Now we will define the exact solution to our problem;</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=font-style:italic># Exact solution to the PDE</span>
</span></span><span style=display:flex><span><span style=font-weight:700>def</span> func(x):
</span></span><span style=display:flex><span>  <span style=font-weight:700>return</span> x[:, 0:1]**2 * x[:, 1:]
</span></span></code></pre></div><p>We can ignor the above method, if we do not know the exact solution to the problem. Let us generate the data now;</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span>data = dde.data.PDE(geom, pde, bc, num_domain=4000, solution=func, num_boundary=2000, train_distribution=<span style=font-style:italic>&#39;Hammersley&#39;</span>, num_test=5000)
</span></span></code></pre></div><p>The <strong>data</strong> we obtained above have several attributes and methods that we can access;</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span>print(dir(data))
</span></span><span style=display:flex><span>&gt;&gt; [<span style=font-style:italic>&#39;__abstractmethods__&#39;</span>, <span style=font-style:italic>&#39;__class__&#39;</span>, <span style=font-style:italic>&#39;__delattr__&#39;</span>, <span style=font-style:italic>&#39;__dict__&#39;</span>, <span style=font-style:italic>&#39;__dir__&#39;</span>, <span style=font-style:italic>&#39;__doc__&#39;</span>, <span style=font-style:italic>&#39;__eq__&#39;</span>, <span style=font-style:italic>&#39;__format__&#39;</span>, <span style=font-style:italic>&#39;__ge__&#39;</span>, <span style=font-style:italic>&#39;__getattribute__&#39;</span>, <span style=font-style:italic>&#39;__gt__&#39;</span>, <span style=font-style:italic>&#39;__hash__&#39;</span>, <span style=font-style:italic>&#39;__init__&#39;</span>, <span style=font-style:italic>&#39;__init_subclass__&#39;</span>, <span style=font-style:italic>&#39;__le__&#39;</span>, <span style=font-style:italic>&#39;__lt__&#39;</span>, <span style=font-style:italic>&#39;__module__&#39;</span>, <span style=font-style:italic>&#39;__ne__&#39;</span>, <span style=font-style:italic>&#39;__new__&#39;</span>, <span style=font-style:italic>&#39;__reduce__&#39;</span>, <span style=font-style:italic>&#39;__reduce_ex__&#39;</span>, <span style=font-style:italic>&#39;__repr__&#39;</span>, <span style=font-style:italic>&#39;__setattr__&#39;</span>, <span style=font-style:italic>&#39;__sizeof__&#39;</span>, <span style=font-style:italic>&#39;__slots__&#39;</span>, <span style=font-style:italic>&#39;__str__&#39;</span>, <span style=font-style:italic>&#39;__subclasshook__&#39;</span>, <span style=font-style:italic>&#39;__weakref__&#39;</span>, <span style=font-style:italic>&#39;_abc_impl&#39;</span>, <span style=font-style:italic>&#39;add_anchors&#39;</span>, <span style=font-style:italic>&#39;anchors&#39;</span>, <span style=font-style:italic>&#39;auxiliary_var_fn&#39;</span>, <span style=font-style:italic>&#39;bc_points&#39;</span>, <span style=font-style:italic>&#39;bcs&#39;</span>, <span style=font-style:italic>&#39;exclusions&#39;</span>, <span style=font-style:italic>&#39;geom&#39;</span>, <span style=font-style:italic>&#39;losses&#39;</span>, <span style=font-style:italic>&#39;losses_test&#39;</span>, <span style=font-style:italic>&#39;losses_train&#39;</span>, <span style=font-style:italic>&#39;num_bcs&#39;</span>, <span style=font-style:italic>&#39;num_boundary&#39;</span>, <span style=font-style:italic>&#39;num_domain&#39;</span>, <span style=font-style:italic>&#39;num_test&#39;</span>, <span style=font-style:italic>&#39;pde&#39;</span>, <span style=font-style:italic>&#39;replace_with_anchors&#39;</span>, <span style=font-style:italic>&#39;resample_train_points&#39;</span>, <span style=font-style:italic>&#39;soln&#39;</span>, <span style=font-style:italic>&#39;test&#39;</span>, <span style=font-style:italic>&#39;test_aux_vars&#39;</span>, <span style=font-style:italic>&#39;test_points&#39;</span>, <span style=font-style:italic>&#39;test_x&#39;</span>, <span style=font-style:italic>&#39;test_y&#39;</span>, <span style=font-style:italic>&#39;train_aux_vars&#39;</span>, <span style=font-style:italic>&#39;train_distribution&#39;</span>, <span style=font-style:italic>&#39;train_next_batch&#39;</span>, <span style=font-style:italic>&#39;train_points&#39;</span>, <span style=font-style:italic>&#39;train_x&#39;</span>, <span style=font-style:italic>&#39;train_x_all&#39;</span>, <span style=font-style:italic>&#39;train_x_bc&#39;</span>, <span style=font-style:italic>&#39;train_y&#39;</span>]
</span></span></code></pre></div><p>It is equally important to ensure the following in order to avoid any errors:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span>print(type(data.train_x))
</span></span><span style=display:flex><span>print(type(data.train_y))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&gt;&gt;&gt; &lt;<span style=font-weight:700>class</span> <span>&#39;</span><span style=font-weight:700>numpy</span>.ndarray<span style=font-style:italic>&#39;&gt;</span>
</span></span><span style=display:flex><span>&gt;&gt;&gt; &lt;<span style=font-weight:700>class</span> <span>&#39;</span><span style=font-weight:700>numpy</span>.ndarray<span style=font-style:italic>&#39;&gt;</span>
</span></span></code></pre></div><p><strong>Network</strong></p><p>Next we define a fully connected neural network (FNN) with 2 input nodes, 4 hidden layers of 50 nodes each with a tanh activation function, and 1 output node. The weights are initialized using Glorot uniform distribution and a dropout rate of 0.25 is applied to the hidden layers during training.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span>net = dde.nn.FNN([2] + [50] + [50] + [50] + [50] + [1], <span style=font-style:italic>&#34;tanh&#34;</span> , <span style=font-style:italic>&#34;Glorot uniform&#34;</span>, dropout_rate= 0.25)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>model = dde.Model(data, net)
</span></span><span style=display:flex><span>model.compile(<span style=font-style:italic>&#34;adam&#34;</span>, lr=0.0001)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>model.train(iterations=20000)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>model.compile(<span style=font-style:italic>&#34;L-BFGS&#34;</span>)
</span></span><span style=display:flex><span>losshistory, train_state = model.train()
</span></span><span style=display:flex><span>dde.saveplot(losshistory, train_state, issave=<span style=font-weight:700>True</span>, isplot=<span style=font-weight:700>True</span>)
</span></span></code></pre></div><p>The code above calls <strong>model.compile</strong> twice because the first time it sets up the training process with the Adam optimizer and a learning rate of 0.0001. The second call only sets the optimizer argument to &ldquo;L-BFGS&rdquo;, which is another optimization algorithm used for training neural networks.</p><p>The goal of using different optimization algorithms is to find the best parameters for the model that minimize the loss function. Adam is a stochastic gradient descent method that uses adaptive learning rates, while L-BFGS is a quasi-Newton method that approximates the Hessian matrix of the loss function. Both have their own strengths and weaknesses, and it is common to try different optimization algorithms to find the best one for a particular problem.</p><p>After calling <strong>model.train</strong> with 20000 iterations, the loss history and training state are saved using <strong>dde.saveplot</strong>. Following figure shows the training and testing loss for different steps;</p><figure class=center><img src=https://AIThoughtLab.github.io/ThinkingAI/images/loss1.png></figure><p>Now let us visualize the predicted solution and exact solution to the given Poisson equation. Following code shows the output from the exact solution formula;</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=font-weight:700>def</span> func(x):
</span></span><span style=display:flex><span>  <span style=font-weight:700>return</span> x[:, 0:1]**2 * x[:, 1:]
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>y_true = func(train_state.X_test)
</span></span></code></pre></div><p>The figure below shows the solution generated using PINN and the exact solution;<figure class=center><img src=https://AIThoughtLab.github.io/ThinkingAI/images/solutions.png></figure></p><p><strong>Conclusion</strong></p><p>To sum up, Physics-Informed Neural Networks (PINNs) provide an effective solution to ODE or PDE problems by leveraging both physics-based modeling and deep learning. They are capable of handling complicated geometries and boundary conditions, have low data requirements when compared to traditional numerical methods, and can rapidly produce precise results across a broad range of issues. Moreover, since PINNs can include physical laws and restrictions into the model, the results they produce are more interpretable and have greater physical meaning.</p><p><strong>Reference:</strong></p><ol><li><a href=https://deepxde.readthedocs.io/en/latest/index.html>https://deepxde.readthedocs.io/en/latest/index.html</a></li></ol></article></section></div><script type=text/javascript src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></main><script src=https://AIThoughtLab.github.io/ThinkingAI/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>