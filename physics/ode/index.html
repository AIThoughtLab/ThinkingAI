<!doctype html><html lang=en><head><title>Second order Ordinary Differential Equation Â· AI for HUMANITY</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Mohamed ABDUL GAFOOR"><meta name=description content="Second-Order Ordinary differential equation (ODE)
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-
&ndash;When a system is subject to a periodic forcing with a frequency that is equal to its natural frequency, it results in resonance. In forced oscillation, the frequency of the periodic force is denoted by \(\omega\) while the natural frequency of the system is denoted by \(\omega_{0}\). When \(\omega\) and \(\omega_{0}\) are equal, the amplitude of the oscillation increases significantly, leading to resonance. Resonance can be observed in a variety of physical systems, including mechanical, electrical, and acoustic systems."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Second order Ordinary Differential Equation"><meta name=twitter:description content="Second-Order Ordinary differential equation (ODE)
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-
&ndash;When a system is subject to a periodic forcing with a frequency that is equal to its natural frequency, it results in resonance. In forced oscillation, the frequency of the periodic force is denoted by \(\omega\) while the natural frequency of the system is denoted by \(\omega_{0}\). When \(\omega\) and \(\omega_{0}\) are equal, the amplitude of the oscillation increases significantly, leading to resonance. Resonance can be observed in a variety of physical systems, including mechanical, electrical, and acoustic systems."><meta property="og:title" content="Second order Ordinary Differential Equation"><meta property="og:description" content="Second-Order Ordinary differential equation (ODE)
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-
&ndash;When a system is subject to a periodic forcing with a frequency that is equal to its natural frequency, it results in resonance. In forced oscillation, the frequency of the periodic force is denoted by \(\omega\) while the natural frequency of the system is denoted by \(\omega_{0}\). When \(\omega\) and \(\omega_{0}\) are equal, the amplitude of the oscillation increases significantly, leading to resonance. Resonance can be observed in a variety of physical systems, including mechanical, electrical, and acoustic systems."><meta property="og:type" content="article"><meta property="og:url" content="https://AIThoughtLab.github.io/ThinkingAI/physics/ode/"><meta property="article:section" content="physics"><meta property="article:published_time" content="2022-12-05T00:00:00+00:00"><meta property="article:modified_time" content="2022-12-05T00:00:00+00:00"><link rel=canonical href=https://AIThoughtLab.github.io/ThinkingAI/physics/ode/><link rel=preload href="https://AIThoughtLab.github.io/ThinkingAI/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=https://AIThoughtLab.github.io/ThinkingAI/css/coder.min.36f76aaf39a14ecf5c3a3c6250dcaf06c238b3d8365d17d646f95cb1874e852b.css integrity="sha256-NvdqrzmhTs9cOjxiUNyvBsI4s9g2XRfWRvlcsYdOhSs=" crossorigin=anonymous media=screen><link rel=stylesheet href=https://AIThoughtLab.github.io/ThinkingAI/css/coder-dark.min.593028e7f7ac55c003b79c230d1cd411bb4ca53b31556c3abb7f027170e646e9.css integrity="sha256-WTAo5/esVcADt5wjDRzUEbtMpTsxVWw6u38CcXDmRuk=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=https://AIThoughtLab.github.io/ThinkingAI/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=https://AIThoughtLab.github.io/ThinkingAI/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=https://AIThoughtLab.github.io/ThinkingAI/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=https://AIThoughtLab.github.io/ThinkingAI/images/apple-touch-icon.png><link rel=manifest href=https://AIThoughtLab.github.io/ThinkingAI/site.webmanifest><link rel=mask-icon href=https://AIThoughtLab.github.io/ThinkingAI/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.111.3"></head><body class="preload-transitions colorscheme-dark"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://AIThoughtLab.github.io/ThinkingAI/>AI for HUMANITY</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=https://AIThoughtLab.github.io/ThinkingAI/about/>About</a></li><li class=navigation-item><a class=navigation-link href=https://AIThoughtLab.github.io/ThinkingAI/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=https://AIThoughtLab.github.io/ThinkingAI/projects/>Projects</a></li><li class=navigation-item><a class=navigation-link href=https://AIThoughtLab.github.io/ThinkingAI/physics/>PINN</a></li><li class=navigation-item><a class=navigation-link href=https://AIThoughtLab.github.io/ThinkingAI/innovations/>Innovations</a></li><li class=navigation-item><a class=navigation-link href=https://AIThoughtLab.github.io/ThinkingAI/personal/>Personal</a></li><li class=navigation-item><a class=navigation-link href=https://AIThoughtLab.github.io/ThinkingAI/contact/>Contact me</a></li></ul></section></nav><div class=content><section class="container page"><article><header><h1 class=title><a class=title-link href=https://AIThoughtLab.github.io/ThinkingAI/physics/ode/>Second order Ordinary Differential Equation</a></h1></header><p><strong>Second-Order Ordinary differential equation (ODE)</strong></p><p><em>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</em></p><p><em>&ndash;When a system is subject to a periodic forcing with a frequency that is equal to its natural frequency, it results in resonance. In forced oscillation, the frequency of the periodic force is denoted by \(\omega\) while the natural frequency of the system is denoted by \(\omega_{0}\). When \(\omega\) and \(\omega_{0}\) are equal, the amplitude of the oscillation increases significantly, leading to resonance. Resonance can be observed in a variety of physical systems, including mechanical, electrical, and acoustic systems. It can be both useful and destructive, depending on the context in which it occurs.&ndash;</em></p><p><em>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</em></p><p>In this post, we will delve into the topic of second-order ordinary differential equations (ODEs) and explore how to solve them using a deep learning technique. Specially, we will employ a Python library called &ldquo;DeepXDE&rdquo; to accomplish this task.</p><p>A second-order ODE is a kind of differential equation that deals with a function&rsquo;s second derivative with respect to its independent variable. The standard form of a second-order ODE is;</p><p>$$y&rsquo;&rsquo;(x) + p(x)y&rsquo;(x) + q(x)y(x) = r(x)$$</p><p>where \(y(x)\) is the function that we are trying to find, and \(p(x)\), \(q(x)\), and \(r(x)\) are functions that are known to us.</p><p>This equation is applicable in various fields such as Physics, Engineering, and Mathematics, and is used to model different phenomena such as the movement of a mass on a spring, the vibrations of a string, and the flow of fluids.</p><p>Solving a second-order ODE involves finding a function \(y(x)\) that satisfies the equation for a specific set of initial or boundary conditions. This can be achieved through analytical methods such as separation of variables, integrating factors, and Laplace transforms, or numerical methods such as the Euler&rsquo;s method, the Runge-Kutta method, or finite difference methods.</p><p>In this post we will solve an ODE in the following form;</p><p>$${y}&rsquo;&rsquo; + \omega _{0}^2y = \frac{F_0}{m} cos(\omega _{0}t)$$</p><p>with initial conditions;
$$ y(0) = 0, y&rsquo;(0) = \frac{F_0}{2m\omega _{0}} $$</p><p>Let us assume \(F_0 = 10N\), \(m = 2kg\), \(\omega _{0} = 4\)..</p><p>Hence, our equation turns into;
$${y}&rsquo;&rsquo; + 4^2y = \frac{10}{2} cos(4t)$$</p><p>with the initial conditions;
$$ y(0) = 0, y&rsquo;(0) = 0.625 $$</p><p>The exact solution to this problem is;
$$y = \frac{5t.sin(4t)}{8} + 0.15625.sin(4t)$$</p><p>We can start the process by first defining a computational geometry for our simulation. One approach is to use a built-in class called TimeDomain. To do so, we can use the following code:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=font-weight:700>import</span> <span style=font-weight:700>deepxde</span> <span style=font-weight:700>as</span> <span style=font-weight:700>dde</span>
</span></span><span style=display:flex><span><span style=font-weight:700>import</span> <span style=font-weight:700>numpy</span> <span style=font-weight:700>as</span> <span style=font-weight:700>np</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>geom = dde.geometry.TimeDomain(0, 5) <span style=font-style:italic># Time interval between 0 to 5.</span>
</span></span></code></pre></div><p>Next, we will define residual of the ODE, in the context of solving an ODE numerically, the residual refers to the difference between the left-hand side (LHS) and the right-hand side (RHS) of the ODE after substituting the numerical solution at a given time point.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=font-weight:700>def</span> ode(t, y):
</span></span><span style=display:flex><span>    d2y_dt2 = dde.grad.hessian(y, t)
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> d2y_dt2 + 16*y - 5*dde.backend.cos(4*t)
</span></span></code></pre></div><p>The first argument here is the t-coordinate and the second argument is the network output, i.e., the solution \(y(t)\).</p><p><strong>Initial conditions</strong></p><p>Next, time to define initial conditions, when \(t = 0; y(0) = 0\).</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=font-style:italic># when t = 0; y(0) = 0</span>
</span></span><span style=display:flex><span>ic1 = dde.icbc.IC(geom, <span style=font-weight:700>lambda</span> x: 0, <span style=font-weight:700>lambda</span> _, on_initial: on_initial)
</span></span></code></pre></div><p>Similarly; when \(t = 0; y&rsquo;(0) = 0.625\). However, this is quite complicated as we deal with initial condition with a first derivative.
We must write a function that should return True for those points satisfying t=0 and False otherwise. Note that because of rounding-off errors, it is often wise to use np.isclose to test whether two floating point values are equivalent [1].</p><p>Following is the function that returns the error of the initial condition, \(y&rsquo;(0)=0.625\);</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=font-weight:700>def</span> boundary(t, on_boundary):
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> on_boundary <span style=font-weight:700>and</span> np.isclose(t[0], 0)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>def</span> error(inputs, outputs, X):
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> dde.grad.jacobian(outputs, inputs, i=0, j=<span style=font-weight:700>None</span>) - 0.625
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-style:italic># Second initial condition is</span>
</span></span><span style=display:flex><span>ic2 = dde.icbc.OperatorBC(geom, error, boundary)
</span></span></code></pre></div><p><strong>- There is a note regarding the use of the variable X in the func function. If X is used in func, then num_test should not be set when defining the PDE or TimePDE objects in DeepXDE. If num_test is set, then DeepXDE will throw an error.</strong></p><p>Now we will define the exact solution to our problem;</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=font-style:italic># Exact solution to the ODE</span>
</span></span><span style=display:flex><span><span style=font-weight:700>def</span> func(t):
</span></span><span style=display:flex><span>  <span style=font-weight:700>return</span> (5*t*np.sin(4*t))/8 + 0.15625*np.sin(4*t)
</span></span></code></pre></div><p>We can ignor the above method, if we do not know the exact solution to the problem. Let us generate the data now;</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span>data = dde.data.TimePDE(geom, ode, [ic1, ic2], 160, 20, solution=func, num_test=500)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-style:italic>#  TimePDE has several attributes and methods that you can access</span>
</span></span><span style=display:flex><span>print(dir(data))
</span></span><span style=display:flex><span>print(data.train_x.shape)
</span></span><span style=display:flex><span>print(data.train_y.shape)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&gt;&gt;&gt;
</span></span><span style=display:flex><span>[<span style=font-style:italic>&#39;__abstractmethods__&#39;</span>, <span style=font-style:italic>&#39;__class__&#39;</span>, <span style=font-style:italic>&#39;__delattr__&#39;</span>, <span style=font-style:italic>&#39;__dict__&#39;</span>, <span style=font-style:italic>&#39;__dir__&#39;</span>, <span style=font-style:italic>&#39;__doc__&#39;</span>, <span style=font-style:italic>&#39;__eq__&#39;</span>, <span style=font-style:italic>&#39;__format__&#39;</span>, <span style=font-style:italic>&#39;__ge__&#39;</span>, <span style=font-style:italic>&#39;__getattribute__&#39;</span>, <span style=font-style:italic>&#39;__gt__&#39;</span>, <span style=font-style:italic>&#39;__hash__&#39;</span>, <span style=font-style:italic>&#39;__init__&#39;</span>, <span style=font-style:italic>&#39;__init_subclass__&#39;</span>, <span style=font-style:italic>&#39;__le__&#39;</span>, <span style=font-style:italic>&#39;__lt__&#39;</span>, <span style=font-style:italic>&#39;__module__&#39;</span>, <span style=font-style:italic>&#39;__ne__&#39;</span>, <span style=font-style:italic>&#39;__new__&#39;</span>, <span style=font-style:italic>&#39;__reduce__&#39;</span>, <span style=font-style:italic>&#39;__reduce_ex__&#39;</span>, <span style=font-style:italic>&#39;__repr__&#39;</span>, <span style=font-style:italic>&#39;__setattr__&#39;</span>, <span style=font-style:italic>&#39;__sizeof__&#39;</span>, <span style=font-style:italic>&#39;__slots__&#39;</span>, <span style=font-style:italic>&#39;__str__&#39;</span>, <span style=font-style:italic>&#39;__subclasshook__&#39;</span>, <span style=font-style:italic>&#39;__weakref__&#39;</span>, <span style=font-style:italic>&#39;_abc_impl&#39;</span>, <span style=font-style:italic>&#39;add_anchors&#39;</span>, <span style=font-style:italic>&#39;anchors&#39;</span>, <span style=font-style:italic>&#39;auxiliary_var_fn&#39;</span>, <span style=font-style:italic>&#39;bc_points&#39;</span>, <span style=font-style:italic>&#39;bcs&#39;</span>, <span style=font-style:italic>&#39;exclusions&#39;</span>, <span style=font-style:italic>&#39;geom&#39;</span>, <span style=font-style:italic>&#39;losses&#39;</span>, <span style=font-style:italic>&#39;losses_test&#39;</span>, <span style=font-style:italic>&#39;losses_train&#39;</span>, <span style=font-style:italic>&#39;num_bcs&#39;</span>, <span style=font-style:italic>&#39;num_boundary&#39;</span>, <span style=font-style:italic>&#39;num_domain&#39;</span>, <span style=font-style:italic>&#39;num_initial&#39;</span>, <span style=font-style:italic>&#39;num_test&#39;</span>, <span style=font-style:italic>&#39;pde&#39;</span>, <span style=font-style:italic>&#39;replace_with_anchors&#39;</span>, <span style=font-style:italic>&#39;resample_train_points&#39;</span>, <span style=font-style:italic>&#39;soln&#39;</span>, <span style=font-style:italic>&#39;test&#39;</span>, <span style=font-style:italic>&#39;test_aux_vars&#39;</span>, <span style=font-style:italic>&#39;test_points&#39;</span>, <span style=font-style:italic>&#39;test_x&#39;</span>, <span style=font-style:italic>&#39;test_y&#39;</span>, <span style=font-style:italic>&#39;train_aux_vars&#39;</span>, <span style=font-style:italic>&#39;train_distribution&#39;</span>, <span style=font-style:italic>&#39;train_next_batch&#39;</span>, <span style=font-style:italic>&#39;train_points&#39;</span>, <span style=font-style:italic>&#39;train_x&#39;</span>, <span style=font-style:italic>&#39;train_x_all&#39;</span>, <span style=font-style:italic>&#39;train_x_bc&#39;</span>, <span style=font-style:italic>&#39;train_y&#39;</span>]
</span></span><span style=display:flex><span>(20, 1)
</span></span><span style=display:flex><span>(20, 1)
</span></span></code></pre></div><p>The numbers 160 and 20 are used to control the number of training points that the neural network will use to learn the underlying pattern of the PDE. By increasing the number of training points, the neural network can learn a more accurate representation of the underlying pattern, which can lead to better predictions. However, increasing the number of training points also requires more computation time and resources. We use here 500 residual points for testing the ODE.</p><p><strong>Network</strong></p><p>Let us build our network. We build a fully connected network of with 3 hidden layers and each layer contains 60 neurons.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span>layer_size = [1] + [60] * 3 + [1]
</span></span><span style=display:flex><span>activation = <span style=font-style:italic>&#34;tanh&#34;</span>
</span></span><span style=display:flex><span>initializer = <span style=font-style:italic>&#34;Glorot uniform&#34;</span>
</span></span><span style=display:flex><span>net = dde.nn.FNN(layer_size, activation, initializer)
</span></span></code></pre></div><p>Now that we have defined the ODE and the network architecture, we can proceed with building a Model object. To train the network, we first choose an optimizer, set the learning rate to 002, and then run the training loop for 15000 iterations. During training, we set the weight of the ODE loss to 0.01, and the weights of the two initial conditions to 0.1 and 1 respectively. We also compute the L2 relative error as a metric to evaluate the model&rsquo;s performance.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span>model = dde.Model(data, net)
</span></span><span style=display:flex><span>model.compile(<span style=font-style:italic>&#34;adam&#34;</span>, lr=.002, loss_weights=[0.01, 0.1, 1], metrics=[<span style=font-style:italic>&#34;l2 relative error&#34;</span>])
</span></span><span style=display:flex><span>losshistory, train_state = model.train(iterations=15000)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>dde.saveplot(losshistory, train_state, issave=<span style=font-weight:700>True</span>, isplot=<span style=font-weight:700>True</span>)
</span></span></code></pre></div><p>Following figure shows the prediction and the exact solution. It is interesting to combine physics knowledge with machine learning.<figure class=center><img src=https://AIThoughtLab.github.io/ThinkingAI/images/pinn1.png></figure></p><p><strong>Conclusion</strong></p><p>In summary, Physics-Informed Neural Networks (PINNs) offer a powerful approach to solving ODE or PDE that combines the strengths of physics-based modeling and deep learning. PINNs can handle complex geometries and boundary conditions, require very little data compared to traditional numerical methods, and able to provide a fast and accurate solution to a wide range of problems. Additionally, PINNs can naturally incorporate physical laws and constraints into the model, leading to more interpretable and physically meaningful results.</p><p><strong>Reference:</strong></p><ol><li><a href=https://deepxde.readthedocs.io/en/latest/index.html>https://deepxde.readthedocs.io/en/latest/index.html</a></li></ol></article></section></div><script type=text/javascript src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></main><script src=https://AIThoughtLab.github.io/ThinkingAI/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>